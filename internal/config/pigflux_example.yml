databases:
  # databases are used to run tests, and they may also be used to store test results.
  database_01:
    # PostgreSQL example
    dsn: "postgres://username:password@localhost:5432/database_name"
    diver: "pgx"
  database_02:
    # MySQL example
    # https://github.com/go-sql-driver/mysql?tab=readme-ov-file#usage
    dsn: "postgres://username:password@localhost:5432/database_name"
    diver: "mysql"
  database_03:
    # MS SQL example
    # https://github.com/denisenkom/go-mssqldb?tab=readme-ov-file#connection-parameters-and-dsn
    dsn: "sqlserver://username:password@host/instance?param1=value&param2=value"
    diver: "sqlserver"
  database_04:
    # if you want to use a database to store test results, then you must specify the insert sql
    # PostgreSQL example
    dsn: "postgres://username:password@example.com:5432/database_name"
    diver: "pgx"
    #
    # Variables:
    #
    #    {MEASUREMENT_NAME} - replaced with the name of the measurement, in SQL source (e.g. not as a parameter)
    #    {MEASUREMENT} - measurement name, added as a parameter,
    #    {FIELDNAMES} - a list of fields names, ordered, added as SQL source
    #    {TAGNAMES} - a list of tag names, ordered, added as SQL source
    #    {FIELDVALUES} - a list of field values, ordered by field name, added as a comma separated list of parameters
    #    {TAGVALUES} - a list of tag values, ordered by tag name, added as a comma separated list of parameters
    #    {FIELDS_JSON} - JSON serialized fields (string), added as a parameter
    #    {TAGS_JSON} - JSON serialized tags (string), added as a parameter
    #    {FIELDS_RAW} - fields as a map, added as a parameter (the driver must be able to handle it)
    #    {TAGS_RAW} - tags as a map, added as a parameter (the driver must be able to handle it)
    #    {FIELDS[name]} - access field value by name, added as a parameter
    #    {TAGS[name]} - access tag value by name, added as a parameter
    #
    insert_sql: |
      INSERT INTO {MEASUREMENT_NAME}("time",{FIELDNAMES},{TAGNAMES}) VALUES (now(), {FIELDVALUES} ,{TAGVALUES} )
  database_05:
    dsn: "postgres://username:password@example.com:5432/database_name"
    diver: "pgx"
    # Alternative sql syntax that uses a jsonb fields for storing fields and tags
    insert_sql: |
      INSERT INTO measurements("time",measurement_name,fields,tags) VALUES (now(), {MEASUREMENT}, 
        cast({FIELDS_JSON} as jsonb) , -- FIELDS_JSON and TAGS_JSON will add a string parameter with json source
        {TAGS_RAW}::jsonb  -- FIELDS_RAW and TAGS_RAW will pass the fields/tags map to the db driver unaltered
      )
influxes:
  # for influx v1 you need address, username, password
  # see https://github.com/influxdata/influxdb/tree/1.8/client#connecting-to-your-database
  influx_srv_01:
    url: "http://localhost:8086"
    username: "user_name"
    password: "password"
    database: "database_name"
    # this is used when sending measurements
    send_timeout: "10s"
  influx_srv_02:
    url: "https://example.com:1234"
    verify_ssl: false
    username: "user_name"
    password: "password"
    database: "database_name"
influxes2:
  # for influx v2, you need an url, and organization, a bucket and a token.
  # example # https://github.com/influxdata/influxdb-client-go?tab=readme-ov-file#basic-example
  influx2_srv_01:
    url: "https://host_05.com"
    org: "dcce8cedb3dad2dc"
    bucket: "iot01"
    token: "B0fXt_c4hYVUjbpXLnrHkjX-UIBeO0YsvQafascEfdGsdVasE_vFrSQhQpZivx8avwwcsax790yw_dSGyufffw=="
    # this is used when sending measurements
    send_timeout: "10s"
influxes3:
  # for influx v3, you can use a connection string url
  # example here https://github.com/InfluxCommunity/influxdb3-go?tab=readme-ov-file#instantiate-using-a-connection-string
  influx3_srv_01:
    url: "https://cluster.influxdata.io/?token=DATABASE_TOKEN&database=DATABASE_NAME"
    # this is used when sending measurements
    send_timeout: "10s"
tests:
  defaults:
    # template will never run, they only serve as a base config that tests can be inherited from
    is_template: true
    # databases specifies the databases where we run the test, you can list more
    databases: [ "database_01", "database_02" ]
    # these specify the target influxdb instances where the test results should be sent,
    # you can specify multiple instances for multiple different types
    influxes: [ "influx_srv_01", "influx_srv_02", "influx2_srv_01" ]
    influxes2: ["influx2_srv_01"]
    influxes3: ["influx3_srv_01"]
    # If the database has an insert_sql then it can also be used to store the measurement
    target_database: ["database_03", "database_04"]
    # template tags serve as a base, they are merged with descendants
    tags:
      tag1: "value1"
      tag2: "value2"
  measurement_01:
    # Now, this is not a template, so it will be executed
    # Order determines the run order of the tests
    order: 1
    # Measurement specifies the target measurement/table where the test results will be saved
    measurement: "measurement_name_01"
    # When inherit_from is given, properties are first inherited from the given parent, and then overwritten
    # (or for tags, merged!)
    inherit_from: "defaults"
    # We expect the SQL to returns these two values, and a single row.
    fields: [ "field1", "field2" ]
    # The SQL that will be used to get values for the fields, it must return a single row
    sql: |
      select
        field1, field2, tag3, tag4
      from table_name_01 order by 2 limit 1
  measurement_02:
    # measurement_02 will be run after measurement_01
    order: 2
    measurement: "measurement_name_02"
    databases: [ "database_01" ]
    target_databases: ["database_03"]
    fields: [ "field1", "field2" ]
    sql: |
      select
        field1, field2, tag3
      from table_name_02 order by 2 limit 1
